\chapter{Demo}\label{ch:demo}

\section{Requisiti}\label{sec:demo-requisiti}

\section{Design architetturale}\label{sec:demo-design-architetturale}
A seguito dell'analisi dei requisiti definiti nella sezione precedente, si è realizzato il design architetturale di
massima riportato in Figura~TODO.

Il pattern architetturale scelto è \ECS, poiché si presta bene a questo genere di applicazioni.

Per non legarsi a una specifica libreria grafica, si è deciso d'introdurre il \textit{façade} \texttt{ECSCanvas}
che espone dei metodi di alto livello per disegnare le primitive richieste (in particolare, cerchio e linea) e ottenere
le dimensioni dell'area di disegno.

\section{Design di dettaglio}\label{sec:demo-design-di-dettaglio}
Per ridurre la complessità nell'implementazione dei sistemi si è deciso di demandare la gestione della posizione delle
palle nello spazio bidimensionale allo \texttt{SpacePartitionContainer}.
Come mostrato in Figura~\ref{todo} sono state realizzate due interfaccie che separano le operazioni di modifica da
quelle di lettura dello stato;
in questo modo si può garantire che solo i sistemi che hanno bisogno di aggiungere elementi al container possano farlo.
Una trattazione più approfondita della logica di funzionamento del container si trova alla Sezione~\ref{todo}.

Si elencano di seguito i sistemi individuati ai fini della realizzazione della demo:
\begin{itemize}
    \item \textbf{AutoPauseSystem}: mette in automatico il gioco in pausa quando nessuna palla è più in movimento
    \item \textbf{BallCreationRenderingSystem}: si occupa di renderizzare la fase di creazione di una nuova palla
    \item \textbf{BallCreationSystem}: aggiunge una nuova palla al \World
    \item \textbf{BallSelectionSystem}: seleziona una palla quando viene cliccata
    \item \textbf{ClearCanvasSystem}: pulisce il canvas a ogni frame
    \item \textbf{CollisionSystem}: calcola le nuove velocità di eventuali entità che collidono fra loro
    \item \textbf{FrictionSystem}: calcola le nuove velocità considerando il coefficente di frizione
    \item \textbf{MovementSystem}: calcola le nuove posizioni delle palle
    \item \textbf{RegionAssignmentSystem}: assegna le palle a specifiche regioni del canvas
    \item \textbf{RenderSystem}: effettua il rendering delle palle
    \item \textbf{VelocityArrowSystem}: disegna il vettore della velocità quando si modifica la velocità a una palla
    \item \textbf{VelocityEditingSystem}: assegna il nuovo valore di velocità a una palla
    \item \textbf{WallCollisionSystem}: gestisce le collisioni delle palle con i muri
\end{itemize}

Per ridurre la complessità nell'implementazione dei sistemi si è deciso di demandare la gestione della posizione delle
palle nello spazio bidimensionale allo \texttt{SpacePartitionContainer}.
Come mostrato in Figura~\ref{todo} sono state realizzate due interfaccie che separano le operazioni di modifica da
quelle di lettura dello stato;
in questo modo si può garantire che solo i sistemi che hanno bisogno di aggiungere elementi al container possano farlo.
Una trattazione più approfondita della logica di funzionamento del container si trova alla Sezione~\ref{subsec:container}.

\subsection{Macchina a stati finiti}\label{subsec:macchina-a-stati-finiti}
Le macchine a stati finiti (FSM) consentono di descrivere formalmente il comportamento di un sistema.
Si è quindi scelto tale formalismo per descrivere il funzionamento della simulazione.

Sono stati identificati sei stati: \textit{Pause}, \textit{Play}, \textit{Add Balls}, \textit{Select Ball},
\textit{Change Velocity} e \textit{Dragging}.
A seguito della definizione degli stati del sistema, sono stati definiti gli eventi di transizione tra stati.
Di seguito viene riportata la descrizione di tali eventi:
\begin{itemize}
    \item \textit{PlayPauseBtn.clicked}: rappresenta la pressione del pulsante per eseguire o mettere in pausa la
    simulazione
    \item \textit{AddBallBtn.clicked}: rappresenta la pressione del pulsante per l'aggiunta di palle alla simulazione
    \item \textit{ChangeVelBtn.clicked}: rappresenta la pressione del pulsante per cambiare la velocità a una palla
    \item \textit{Ball.selected}: rappresenta l'evento di selezione di una palla
    \item \textit{Mouse.clicked}: rappresenta il singolo click del mouse
    \item \textit{Mouse.dragging}: rappresenta l'evento di trascinamento del mouse
    \item \textit{Mouse.released}: rappresenta l'evento di rilascio del tasto del mouse
\end{itemize}

In Figura~\ref{fig:fsm-demo} viene riportata la macchina a stati finiti utilizzata per descrivere il comportamento
della simulazione.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{img/fsm-demo}
    \caption{Macchina a stati finiti che modella il flusso di esecuzione della demo.}\label{fig:fsm-demo}
\end{figure}

In una prima implementazione della demo si erano definiti oggetti globali che mantenessero lo stato della simulazione.
Ben presto ci si è resi conto della difficoltà nel gestire tutte le combinazioni dei campi dell'oggetto, oltre
ai vari bug che si verificavano durante l'implementazione della demo.
L'introduzione della macchina a stati ha portato diversi vantaggi: si è semplificata la gestione dello
stato di simulazione, le precondizioni di esecuzione dei sistemi fanno riferimento allo stato della FSM e non più alla
combinazione di più variabili booleane e la logica di aggiornamento dei componenti della GUI si è semplificata
notevolmente.
Grazie alla FMS è stato implementato un testing esaustivo delle precondizioni dei sistemi, esaminando tutte
le possibili configurazioni della FSM in unione agli eventi del mouse.
Grazie a questo è stato possibile individuare piccoli bug nella logica dei \System e inconsistenze nell'interfaccia
grafica.

Infine, grazie al contributo di Cavalieri, sono stati predisposti dei test per l'interfaccia grafica volti a verificare
la correttezza della FSM. Per una trattazione approfondita sui test della GUI si faccia riferimento alla
Sezione~\ref{TODO}.

\section{Implementazione}\label{sec:demo-implementazione}
\subsection{Macchina a stati finiti}\label{subsec:macchina-a-stati-finiti}
Le macchine a stati finiti (FSM) consentono di descrivere formalmente il comportamento di un sistema.
Si è quindi scelto tale formalismo per descrivere il funzionamento della simulazione.

Sono stati identificati sei stati: \textit{Pause}, \textit{Play}, \textit{Add Balls}, \textit{Select Ball},
\textit{Change Velocity} e \textit{Dragging}.
A seguito della definizione degli stati del sistema, sono stati definiti gli eventi di transizione tra stati.
Di seguito viene riportata la descrizione di tali eventi:
\begin{itemize}
    \item \textit{PlayPauseBtn.clicked}: rappresenta la pressione del pulsante per eseguire o mettere in pausa la
    simulazione
    \item \textit{AddBallBtn.clicked}: rappresenta la pressione del pulsante per l'aggiunta di palle alla simulazione
    \item \textit{ChangeVelBtn.clicked}: rappresenta la pressione del pulsante per cambiare la velocità a una palla
    \item \textit{Ball.selected}: rappresenta l'evento di selezione di una palla
    \item \textit{Mouse.clicked}: rappresenta il singolo click del mouse
    \item \textit{Mouse.dragging}: rappresenta l'evento di trascinamento del mouse
    \item \textit{Mouse.released}: rappresenta l'evento di rilascio del tasto del mouse
\end{itemize}

In Figura~\ref{fig:fsm-demo} viene riportata la macchina a stati finiti utilizzata per descrivere il comportamento
della simulazione.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{img/fsm-demo}
    \caption{Macchina a stati finiti che modella il flusso di esecuzione della demo.}\label{fig:fsm-demo}
\end{figure}

In una prima implementazione della demo si erano definiti oggetti globali che mantenessero lo stato della simulazione.
Ben presto ci si è resi conto della difficoltà nel gestire tutte le combinazioni dei campi dell'oggetto, oltre
ai vari bug che si verificavano durante l'implementazione della demo.
L'introduzione della macchina a stati ha portato diversi vantaggi: si è semplificata la gestione dello
stato di simulazione, le precondizioni di esecuzione dei sistemi fanno riferimento allo stato della FSM e non più alla
combinazione di più variabili booleane e la logica di aggiornamento dei componenti della GUI si è semplificata
notevolmente.
Grazie alla FMS è stato implementato un testing esaustivo delle precondizioni dei sistemi, esaminando tutte
le possibili configurazioni della FSM in unione agli eventi del mouse.
Grazie a questo è stato possibile individuare piccoli bug nella logica dei \System e inconsistenze nell'interfaccia
grafica.

Infine, grazie al contributo di Cavalieri, sono stati predisposti dei test per l'interfaccia grafica volti a verificare
la correttezza della FSM. Per una trattazione approfondita sui test della GUI si faccia riferimento alla
Sezione~\ref{TODO}.

\section{Implementazione}\label{sec:demo-implementazione}

\subsection{Farabegoli}\label{subsec:farabegoli2}
\subsubsection{Game loop}
Mi sono occupato della realizzazione del \textit{game loop} facendo uso della classe \texttt{AnimationTimer} già
presente in \texttt{scalafx}.
Tale classe consente di eseguire del codice implementandolo nel metodo \texttt{handle()}.
Questo metodo viene chiamato a ogni frame: un frame è renderizzato ogni $\approx16.6$ millisecondi per garantire 60 FPS
(Frame Per Seconds).
Il limite di 60 FPS è automaticamente garantito dalla classe, quindi non è necessario implementare una logica di
limitazione degli FPS\@; nel caso in cui si verifichi overrun, sarà compito della classe regolare di conseguenza gli
FPS\@.

La suddetta classe è stata concepita per essere utilizzata in un contesto OOP, per questa ragione è una classe astratta
che forza l'implementazione del metodo \texttt{handle()}.
Ho quindi deciso di trasformare la classe affinché avesse un comportamento più funzionale.
È stato quindi creato un wrapper attorno alla classe per consentire di specificare l'handler del metodo direttamente
dal costruttore della classe mediante passaggio di funzione.

Nel Listato~\ref{lst:lstinputlisting3} è illustrato come è stato effettuato il wrapping della classe
\texttt{AnimationTimer}.

\lstinputlisting[label={lst:lstinputlisting3}, caption=Esempio d'implementazione del game loop mediante la classe
\texttt{AnimationTimer}]{code/game-loop.sc}

Con l'\texttt{apply()} è possibile specificare, mediante una lambda, il codice che deve essere eseguito a ogni
frame.
Con i metodi \texttt{start} e \texttt{stop} è possibile rispettivamente eseguire il game loop e fermarlo.
Nel listato appena mostrato per semplicità è stata omessa la parte di calcolo degli FPS\@.


\subsubsection{FSM}
Mi sono occupato di realizzare la macchina a stati per gestire la logica del simulatore.
Per una trattazione dettagliata fare riferimento alla Sezione~\ref{subsec:macchina-a-stati-finiti}

\subsubsection{Interfaccia utente}
Mi sono occupato della realizzazione del'interfaccia grafica del simulatore;
a tal proposito si è fatto uso della libreria \texttt{scalafx}~\cite{scalafx}, la quale offre un DSL per la creazione
d'interfaccie grafiche.

L'interfaccia si compone di una singola finestra che mostra una serie di bottoni per far interagire l'utente con la
simulazione, oltre a un pannello composto da due slider che consentono di configurare parametri di simulazione.
Al centro della finestra è presente un canvas che renderizza gli oggetti della simulazione.
L'interfaccia utente è stata sviluppata nell'ottica KISS in quanto si vuole fornire la massima semplicità d'uso
all'utente.

Di seguito si riportano gli aspetti implementativi che meritano una trattazione più approfondita.

\subsection{Di Domenico}\label{subsec:demo-di-domenico}

\subsubsection{Collision System}\label{subsec:container}
Il sistema principale che gestisce la simulazione è il \texttt{CollisionSystem}: questo implementa i calcoli necessari
per testare se c'è una collisione fra due corpi e, in caso affermativo, calcolarne le nuove velocità.

Sarebbe necessario controllare tutte le possibili coppie di corpi, ma questo presenta due importanti problemi:
\begin{itemize}
    \item ogni coppia di entità compare due volte anziché una
    \item la gran parte delle coppie di entità non porterà a una collisione, essendo troppo distanti fra loro
\end{itemize}

La soluzione a entrambi questi problemi è stata quella di applicare la tecnica di ottimizzazione detta
\textit{space partitioning}: si divide lo spazio (il piano in questo caso, essendo una simulazione 2D) in regioni disgiunte
affinché ogni entità appartenga a una e una sola di esse.

\subsubsection{SpacePartitionContainer}
Per ottimizzare i test di collisione è stato creato lo \texttt{SpacePartitionContainer}, che prende in ingresso
un'entità con tutti i componenti richiesti e la salva in una mappa che associa ogni regione (identificata da una coppia
di numeri interi) alla lista di entità che ne fanno parte.
Inoltre, lo \texttt{SpacePartitionContainer} dispone di un metodo per ottenere tutte le entità facente parte di una regione
specificata, e uno per iterare su tutte le regioni non vuote.

A questo punto, il \texttt{CollisionSystem} può diventare molto più efficiente: ora è sufficiente iterare su tutte le regioni
non vuote e testare le collisioni solo fra entità che fanno parte di un intorno bidimensionale di quelle regioni, come
mostrato in Figura~\ref{fig:space-partition}.
Per non processare due volte le coppie di entità, si costruiscono tutte le possibili combinazioni di lunghezza 2 e si
considera solo una metà dell'intorno, mentre l'altra verrà coperta nelle successive iterazioni delle regioni non vuote.

\begin{figure}[htp]
    \centering
    \begin{tikzpicture}
        \fill[red!15!white] (1.5, 6) rectangle (4.5, 3);
        \fill[red!15!white] (1.5, 3) rectangle (3, 1.5);
        \draw[step=1.5cm,gray,thin] (0, 0) grid (7.5, 7.5);
        \draw[thick,->] (0, 7.5) -- (7.5, 7.5) node[above=2mm] {x};
        \draw[thick,->] (0, 7.5) -- (0, 0) node[left=2mm] {y};
        \foreach \x [count=\i from 0] in {0, 1.5, 3, 4.5, 6}
        \draw (0.75+\x, 7.6) -- (0.75+\x, 7.4) node[above=2mm]{$\i$};
        \foreach \y [count=\i from 0] in {0, 1.5, 3, 4.5, 6}
        \draw (-0.1, 6.75-\y) -- (0.1, 6.75-\y) node[left=2mm]{$\i$};
        \draw (3.75, 4.2) circle (0.75cm);
        \filldraw[black] (3.75, 4.2) circle (2pt) node[anchor=west]{$C_1$};
        \draw (2.55, 5.1) circle (0.75cm);
        \filldraw[black] (2.55, 5.1) circle (2pt) node[anchor=west]{$C_2$};
        \draw (2.1, 2.1) circle (0.75cm);
        \filldraw[black] (2.1, 2.1) circle (2pt) node[anchor=west]{$C_3$};
        \draw (6.5, 6.5) circle (0.75cm);
        \filldraw[black] (6.5, 6.5) circle (2pt) node[anchor=west]{$C_4$};
    \end{tikzpicture}
    \caption{La regione in esame $(2, 2)$ controllerà solo se c'è collisione fra i cerchi con centro nelle regioni limitrofe (l'area rossa);
    si considera solo metà intorno per non contare due volte le coppie nelle iterazioni successive;
    si testerà quindi la collisione fra $C_1$ e $C_2$ e fra $C_1$ e $C_3$, mentre $C_4$ non viene preso in considerazione.}
    \label{fig:space-partition}
\end{figure}
